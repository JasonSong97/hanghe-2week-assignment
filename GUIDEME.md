# 과제 및 요구사항 분석

## 명세의 기준
- 특강 신청 서비스
- 토요일 특강을 신청할 수 있는 서비스
- 특강 신청 및 신청자 목록 관리를 RDBMS를 이용

## 요구사항
- `특강 신청 API` ****
  - userId로 선착순으로 제공되는 특강을 신청하는 API
  - 동일한 신청자는 동일한 강의에 대해서 한 번의 수강 신청만 성공
  - 특강은 선착순 30명만 신청 가능
  - 신청자가 30명 초과 시, 이후 신청자는 요청 실패
- `특강 목록 API`
  - 날짜별로 현재 신청 가능한 특강 목록을 조회
  - 특강의 전원은 30명 고려, 사용자는 각 특강에 신청하기 전 목록을 조회할 수 있음
- `특강 신청 여부 조회 API`
  - user로 신청 완료된 특강 목록을 조회하는 API
  - 각 항목은 lectureId, lectureName, lectureInformation
- 각 기능 및 제약 사항에 대해 단위 테스트를 반드시 하나 이상 작성
- 동시성 이슈를 고려하여 구현
- DB는 MySQL or MariaDB
- Test는 인 메모리 DB(H2 데이터베이스) / Docker-compose(TestContainer) 정도 허용

## 키 포인트
- 정확하게 `30명의 사용자`에게만 특강을 제공
- `같은 사용자에게 여러 번의 특강 슬롯이 제공되지 않도록 제한`할 방법을 고민

## 순서

- 1. 필수
  - `클린 아키텍처 준수 APP 설계`
  - `ERD 설계 및 목록/신청 기본 기능 구현`
  - `각 기능의 단위 테스트 작성`
- 2. 두번째 업그레이드
  - `설계한 테이블에 대한 ERD 및 이유`를 설명하는 README.md 작성
  - `선착순 30명 이후 신청자는 무조건 실패`
  - 동시에 동일한 특강에 대해 31명 초과 신청 시, `30명만 성공하는 것을 검증하는 통합 테스트 작성(테스트 케이스)`
- 3. 세번째 업그레이드
  - `같은 사용자가 동일한 특강은 신청 성공 불가`
  - `동일한 유저 정보로 같은 특강 5번 신청 시`, `1번만 성공하는 것`을 검증하는 `통합 테스트 작성`

## API 문서
- 특강 신청 가능 목록 조회 
  - GET /lectures
  - 특강 신청이 가능한 목록을 조회
  - count가 30미만인 경우
- 특강 신청 완료 목록 조회 
  - GET /lectures/{userId}
  - 특정 userId로 lecture를 조회하고 count가 30인 경우
  - lectureId, lectureTitle, lectureInstructor
- 특강 신청 
  - POST /lecture

# 클린아키텍처
- controller: 사용자 요청을 처리, 서비스에게 전달
- service: 비즈니스 로직 처리, facade에게 의존
- facade: service가 사용하는 비즈니스 레이어 도메인 로직을 조합
- repository: 인터페이스, 데이터 접근 레이어의 추상화
- repositoryImpl: 인터페이스 구현체
- jpa repository: 인프라스트럭처, jpa repositry 상속

## 테스트
- GET /lectures
  - 컨트롤러 단위 테스트
    - [성공] 신청 가능한 목록을 조회하면 신청 가능한 목록을 반환하고 상태코드 200과 상태메세지 OK와 데이터를 반환한다.
  - 서비스 단위 테스트
    - [성공] 신청 가능한 목록을 조회하면 신청 가능한 목록을 반환합니다.
  - 파사드 단위 테스트
    - [성공] 신청 가능한 목록을 조회하면 신청 가능한 목록을 반환합니다.
  - 레포지토리 추상체 단위 테스트
    - 추상체이기 때문에 테스트는 생략합니다.
  - 레포지토리 구현체 단위 테스트
    - [성공] 신청 가능한 목록을 조회하면 신청 가능한 목록을 반환합니다.
  - JPA 레포지토리 인터페이스 단위 테스트
    - 추상체이기 때문에 테스트는 생략합니다.
  - 통합 테스트
    - [성공] 신청 가능한 목록을 조회하면 신청 가능한 목록을 반환합니다.
- GET /lectures/{userId}
  - 컨트롤러 단위 테스트
    - [성공] user가 신청한 강의 목록을 반환하고 상태코드 200과 상태메세지 OK와 데이터를 반환한다.
  - 서비스 단위 테스트
    - [성공] user가 자기가 신청한 강의 목록을 조회하면 신청한 깅의 목록을 반환합니다.
  - 파사드 단위 테스트
    - [성공] user가 자기가 신청한 강의 목록을 조회하면 신청한 깅의 목록을 반환합니다.
  - 레포지토리 추상체 단위 테스트
    - 추상체이기 때문에 테스트는 생략합니다.
  - 레포지토리 구현체 단위 테스트
    - [성공] user가 자기가 신청한 강의 목록을 조회하면 신청한 깅의 목록을 반환합니다.
  - JPA 레포지토리 인터페이스 단위 테스트
    - 추상체이기 때문에 테스트는 생략합니다.
  - 통합 테스트
    - [성공] user가 자기가 신청한 강의 목록을 조회하면 신청한 깅의 목록을 반환합니다.

## 새롭게 알게된 사실
- Spring Data JPA는 List로 반환하면 null 처리를 하기 때문에, 빈 배열로 반환함. 따라서 따로 null처리 할 필요가 없다.
- 가장 먼저 레이어별 어떤 역할을 부여할지 스스로 정해야 한다.
- 비즈니스 로직처리를 꼭 파사드 레이어에서 처리하기 보다는 데이터 필터링의 경우 jpa repositry 레이어에서 처리하면 좋을 것 같다.
- @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  - 진짜 Spring Boot 에플리케이션 컨텍스트를 로드하여 통합 테스트 수행한다는 것
  - 랜덤한 포트에서 애플리케이션이 실행되도록 만듬, 충돌 방지
- ParameterizedTypeReference의 역할은 제네릭 타입의 HTTP응답을 처리할 때 사용
- open in view는 데이터베이스 연결 세션이 HTTP 요청부터 응답까지 열려있다는 의미
- ddl auto를 create-drop으로 설정하면 테이블을 생성 후 삭제한다는 의미